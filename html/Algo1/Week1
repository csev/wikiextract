<div id="content">
				<a id="top"></a>
	        		        	<h1 id="firstHeading" class="firstHeading">Algo1:Week1</h1>
				<div id="bodyContent">
		            <h3 id="siteSub">From Coursera</h3>
		            <div id="contentSub"></div>
		            		            		            					<!-- start content -->
					<div lang="en" dir="ltr" class="mw-content-ltr"><p></p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Algorithms"><span class="tocnumber">1</span> <span class="toctext">Algorithms</span></a></li>
<li class="toclevel-1"><a href="#Karatsuba_Multiplication"><span class="tocnumber">2</span> <span class="toctext">Karatsuba Multiplication</span></a></li>
<li class="toclevel-1"><a href="#Merge_Sort"><span class="tocnumber">3</span> <span class="toctext">Merge Sort</span></a></li>
<li class="toclevel-1"><a href="#Asymptotic_Notation"><span class="tocnumber">4</span> <span class="toctext">Asymptotic Notation</span></a>
<ul>
<li class="toclevel-2"><a href="#Big-Oh"><span class="tocnumber">4.1</span> <span class="toctext">Big-Oh</span></a></li>
<li class="toclevel-2"><a href="#Big-Omega"><span class="tocnumber">4.2</span> <span class="toctext">Big-Omega</span></a></li>
<li class="toclevel-2"><a href="#Big-Theta"><span class="tocnumber">4.3</span> <span class="toctext">Big-Theta</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Divide_and_Conquer"><span class="tocnumber">5</span> <span class="toctext">Divide and Conquer</span></a>
<ul>
<li class="toclevel-2"><a href="#Recursion_and_Recursive_Algorithms"><span class="tocnumber">5.1</span> <span class="toctext">Recursion and Recursive Algorithms</span></a></li>
<li class="toclevel-2"><a href="#Logarithms"><span class="tocnumber">5.2</span> <span class="toctext">Logarithms</span></a></li>
<li class="toclevel-2"><a href="#Mathematical_Induction"><span class="tocnumber">5.3</span> <span class="toctext">Mathematical Induction</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Strassen.E2.80.99s_Algorithm"><span class="tocnumber">6</span> <span class="toctext">Strassenâ€™s Algorithm</span></a></li>
<li class="toclevel-1"><a href="#Closest_Pair"><span class="tocnumber">7</span> <span class="toctext">Closest Pair</span></a></li>
<li class="toclevel-1"><a href="#Categories"><span class="tocnumber">8</span> <span class="toctext">Categories</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Algorithms">Algorithms</span></h2>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Algorithm">Algorithms</a> are similar to recipes. They consist of a set of repeatable steps that produce a consistent result.</p>
<p>Algorithms have existed since the beginning of mathematics, but they really took off with modern computers.</p>
<h2> <span class="mw-headline" id="Karatsuba_Multiplication">Karatsuba Multiplication</span></h2>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba Multiplication</a> shows that there's more than one algorithm for a task, and that algorithm may not be obvious, even if it is more efficient.</p>
<h2> <span class="mw-headline" id="Merge_Sort">Merge Sort</span></h2>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a> sorts a set of comparable elements (such as integers) using recursion.</p>
<h2> <span class="mw-headline" id="Asymptotic_Notation">Asymptotic Notation</span></h2>
<p>Asymptotic Notation allows algorithms to be compared more easily by identifying them by their most influential components.</p>
<p>For example, let's assume that you're having a very unlucky day. You burn your breakfast toast. You get a flat tire on the way to work. Then your boss calls you into his office to let you know that your position is being eliminated. When your spouse asked what happened during your day, you're probably going to lead with losing your job.</p>
<p>Asymptotic notation focuses upon the most important part of an expression. For the most part, we remove all be the most important term and then remove its constant.</p>
<h3> <span class="mw-headline" id="Big-Oh">Big-Oh</span></h3>
<p>$$O()$$ is probably the most common measure. It identifies the upper bound of an expression. For example, if your algorithm is $$O(f(n))$$, then for large enough $$n$$, your algorithm will be less than or equal to $$c\ f(n)$$ for a constant c. For more on <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Big_O_notation">Big-Oh</a>, see this <a rel="nofollow" class="external text" href="https://www.youtube.com/watch?v=ei-A_wy5Yxw">video</a> and <a rel="nofollow" class="external text" href="http://bigocheatsheet.com/">cheat sheet</a>, especially the <a rel="nofollow" class="external text" href="http://bigocheatsheet.com/#chart">chart</a>.</p>
<h3> <span class="mw-headline" id="Big-Omega">Big-Omega</span></h3>
<p>$$\Omega()$$ is almost identical to $$O()$$, except that it defines a lower bound of an expression.</p>
<h3> <span class="mw-headline" id="Big-Theta">Big-Theta</span></h3>
<p>$$\Theta()$$ identifies a common upper and lower bound of an expression. That is an expression is squeezed between two curves of $$\Theta(f(n))$$ except that the lower bound curve will have a smaller constant factor than the upper bound curve.</p>
<h2> <span class="mw-headline" id="Divide_and_Conquer">Divide and Conquer</span></h2>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">Divide and Conquer</a> is an algorithmic technique that breaks down a problem into smaller instances of itself, solves those smaller parts and uses them to construct a solution. Divide and Conquer is usually implemented using recursion.</p>
<h3> <span class="mw-headline" id="Recursion_and_Recursive_Algorithms">Recursion and Recursive Algorithms</span></h3>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Recursion">Recursion</a> and <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Recursion"><em>(computer</em>science) Recursive Algorithms/Programs</a> are important tools to understand. These are programs that call themselves. They must first have a base case, and the self-call must be for a subset of the original problem. If you have only learned about recursion in mathematics, you may not realize how recursion works on trees in computer science - it's essential to understand how a tree can be traversed for the Week 1 homework.  There are some good videos here on recursion - <a rel="nofollow" class="external free" href="http://web.stanford.edu/class/cs106b/lecture-videos.shtml">http://web.stanford.edu/class/cs106b/lecture-videos.shtml</a>. </p>
<p>Recursive programs can be compact and elegant, but they can easily consume a lot of process stack space, so they must be used with care.</p>
<h3> <span class="mw-headline" id="Logarithms">Logarithms</span></h3>
<p>The analysis of recursive algorithms often leads to logarithmic results. Why do they appear so often?</p>
<p>Most mathematical operations have an inverse, that is two operations that reverse each other. The inverse of addition is subtraction. The inverse of multiplication is division.</p>
<p>The inverse of an exponent operation is the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Logarithm">logarithm</a>. Let's first review exponents. This is a fixed base number raised to a certain power. For example $$10^x$$ is an exponent expression, which is basically 10 multiplied by itself x times. $$10^1 = 10$$. $$10^2 = 10 &#42; 10 = 100$$. $$10^3 = 10 &#42; 10 &#42; 10 = 1000$$. </p>
<p>The logarithm works reverses this. If you have $$10^x = 10,000$$, and you want to know what x is, you use logarithms. In this case log(10,000) = 4. That is you have to multiple 10 by itself 4 times to get 10,000.</p>
<p>But were did the 10 go in log(10,000)? Traditionally log(x) represents base 10; however, the properties of logarithms work for any base. If you wish to specify a base, it's represented as a subscript to the lower right of "log". There are several other common log bases, ln() is the logarithm for base e. This is used in physics and life sciences, but it doesn't appear much in computer science. log() and ln() appear on most scientific calculators.</p>
<p>However <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Binary_logarithm">log base 2</a> occurs very frequently in computer science. It is sometimes represented as lg(n), ld(n), or even sometimes as log(n), which can get confusing with the base 10 version. lg(n) occurs frequently in computer science because it's the number of steps needed to split a group of elements into two equal groups repeatedly until you're down to one. Think of the kid's game Hi/Lo. One person thinks of a number from 1 to 100. The player guesses and is told if his guess is too high or too low from the secret number. The player narrows his guesses until the secret number is guessed. If the range were 1 to 1000, how many guesses would be required? It's 10, because lg(1,000) is just under 10, so the 10th guess might be needed.</p>
<p>But calculators don't have lg(x) on them. How do we calculate lg(x)? There's a logarithmic formula for this: lg(x) = log(x)/log(2). That is log(x) of any base is log(x)/log(base), or even ln(x)/ln(base) too.</p>
<p>Logarithms are part of common language, at least in America. We often refer to salaries by the number of "figures" in total annual pay. For example, a person making a 5 figure salary is making between $10,000 and $99,999 per year. A person making a 6 figure salary is making between $100,000 and $999,000 per year, etc. Using the term "x figure salary" is logarithmic (base 10), and usually well understood, even by people who claim they know nothing about logarithms!</p>
<p>To learn more about logarithms, please see: <a rel="nofollow" class="external text" href="https://www.khanacademy.org/math/algebra/logarithms-tutorial">Khan Academy Logarithm Tutorial</a></p>
<p>Here are a few logarithm identities to keep in mind:
<ul><li> $$log(ab) = log(a) + log(b)$$
</li><li> $$log(a^b) = b\ log(a)$$
</li><li> $$log(\frac{1}{a}) = -log(a)$$</p>
</li></ul>

<h3> <span class="mw-headline" id="Mathematical_Induction">Mathematical Induction</span></h3>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Mathematical_induction">Mathematical Induction</a> is a critical tool required for algorithm design and analysis. It's a proof technique that works will with recursive programs and structures. Therefore, induction, especially strong or <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Structural_induction">structural induction</a>.</p>
<h2> <span class="mw-headline" id="Strassen.E2.80.99s_Algorithm">Strassenâ€™s Algorithm</span></h2>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Strassen_algorithm">Strassen's Algorithm</a> multiplies matrices in fewer than $$O(n^3)$$ time, which is just a mind blowing result.</p>
<h2> <span class="mw-headline" id="Closest_Pair"><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Closest_pair_of_points_problem">Closest Pair</a></span></h2>
<h2> <span class="mw-headline" id="Categories">Categories</span></h2>

<!-- 
NewPP limit report
Preprocessor node count: 2/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->


</div><div class="printfooter">
Retrieved from "<a href="https://share.coursera.org/wiki/index.php?title=Algo1:Week1&amp;oldid=29330">https://share.coursera.org/wiki/index.php?title=Algo1:Week1&amp;oldid=29330</a>"</div>
					<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/index.php/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/wiki/index.php?title=Category:Algorithms&amp;action=edit&amp;redlink=1" class="new" title="Category:Algorithms (page does not exist)">Algorithms</a></li></ul></div></div>					<!-- end content -->
									</div>
			</div>