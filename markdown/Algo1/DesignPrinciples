When approaching algorithms, consider these Algorithm Design Principles:

# Brute-Force
These direct route algorithms work, but they may not be the most elegant or efficient. However, they can be useful. When a problem is a bit vague, brute-force thinking may help clarify the vagueness. Use brute-force to confirm that you understand the problem being solved and provide an initial working solution. Once the problem is understood through brute-force, we should always if we can do better, but within context. Knuth wrote, "Premature optimization is the root of all evil." Make sure that there is sufficient return on investment to justify the additional algorithm analysis. Strassen’s matrix multiplication is an example. Matrix multiplication seems almost certainly $$O(n^3)$$, but Strassen showed that it’s < $$O(n^3)$$.

# Free Operations
There are many operations that are free or nearly free. Do these on your data sets, or at least perform a mind exercise with them. Organizing your data this way may lead to an idea of how to solve the problem without adding additional processing cost. Free operations include sort, heap/priority queue, binary tree, hash, depth first search, breadth first search, minimum spanning tree, etc. Basically any operation at or under $$O(n\ log\ n)$$.

# Divide and Conquer
Define the solution in terms of itself and solve recursively. Use the Master Method to evaluate complexity. If the solution doesn't fit the Master Method constraint, which happens in QuickSort analysis for example, then select the desired complexity and use induction to see if it can be confirmed.

# Randomize
Use randomization to obtain better performance on average. Adding randomness to what is usually a deterministic environment is counterintuitive, so it may not seem obvious. However, when data can take on a pathological nature, such as QuickSorting a sorted set of data, then randomization may be an efficient way to address the pathology.

# Greedy Algorithm
"Greed, for lack of a better word, is good." Gordon Gecko - Wall Street (movie). It can be good for algorithms too. Organize a greedy algorithm by processing the max (or min) values of a set and never reconsidering the consequences as you process the elements in order. Greedy algorithms can be effective, since they tend to be linear processing, other than sorting the choices, which is log-linear, but they can be tricky to get correct. Don't forget to consider a priority queue in the implementation.

# Dynamic Programming
Build a solution from the ground up. This is similar to Divide and Conquer, but without much of the Divide portion. Consider the problem as if you already had solved parts. Then see if you have base cases as starting points. Build those parts iteratively upon one another, like a bricks in a wall, until you reach the solution at the top. Dynamic programming problems will occur with recurrence relations (i.e., recursive programs) that have a lot of subproblem overlap, such as the recursive Fibonacci: F(n) = F(n-1) + F(n-2). Note that the solution to F(n-1) will require F(n-2) as well, which is overlap, since it’s used in F(n) too. Don’t recompute F(n-2) more than once if you can avoid it. DP is also useful when you want only one option of the recurrence, i.e., the optimal choice. You don’t know the optional choice in the recurrence, but if you knew it, you would be able to solve the problem. DP recurrences tend to use information retrieved from optimal subproblems rather than pushing work down to smaller portions of the problem. For example most tree algorithms push functionality down to lower parts of the tree and assemble the results. Each subtree needs to execute its own portion of the subproblem. It just doesn’t return values back up. Additionally, trees don’t tend to have overlap, based upon their very structure, so DP techniques usually don’t apply to them.

Use DP to build the optimal sub problems so when you need to make a choice the answer is already there. This will be obvious if your recurrence relation uses the max or min value of subproblems. DP tends to return a numeric result, rather than a structural result. However, a structural result can be back computed by working back through the DP results. Some bread crumbs may be needed to reconstruct the path back.

DP programs tend to use arrays (or array concepts, such as associative arrays) to store results of sub problems. If reconstruction is not required, then some space efficiency may be possible. Many recurrence relations don’t access sub optimal problems way back. They tend to access sub optimal problems only one layer down. Therefore, the DP may only need to maintain layers for sub optimal problems that are actually needed. All others can be discarded once no longer needed. This may cause problems with reconstruction, but it depends upon the problem. Sometimes reconstruction that appears to require all layers may not really require them if one is clever. Each case is different.

# Reductions
Don’t reinvent the wheel. A new unknown problem may really be a known problem in disguise. Before diving head first into creating a new algorithm, make sure you understand the problem. Consider it from different perspectives. It just may be a problem, maybe with some slight adjustments, for which you already have a known efficient algorithm. Reduce your new problem to a known solvable problem.

# Intractables
Sometimes you’re stuck between a rock and a hard place. You’ve exhausted your tool box. No matter what data structure, algorithm or technique you try, you just can’t crack this nut. Maybe there’s a reason. Maybe the problem is intractable; that is, there’s no known efficient solution, so don’t waste your time trying to find one. If an NP-Complete problem reduces to your new problem, then your problem is intractable, but all hope is not lost. Improvements will take creativity and possibly not a lot of performance gains.  NP-Complete problems have no known efficient solutions. Any improvements may be meager and difficult to obtain. 
* Focus on tractable sub problems. While the general solution may be intractable, your operational scenarios may be special specific cases for which there is a tractable solution. Look for specifics or invariants in your scenarios which you may be able to leverage.
* Use heuristics. That is fast algorithms that may not return the optimal solution, but they may return an answer that’s good enough. Consider the traveling salesman problem. The optimal solution is not computable from a practical point a view, but a heuristic that returns 90% of the optimal may be more than acceptable. Consider a heuristic for the Knapsack problem. Chose items based upon their value/size ratio, but add a final step to choose the largest value item if greater than the value/size ratio answer. There’s a reason thieves prefer jewelry over linens. A greedy algorithm based upon a value/size ratio won’t produce the optimal set, but it will produce a reasonable set in much less time. Use local optimization search, which optimizes locally, not  globally. Two cases:
* Start with a heuristic, and use LOS to improve it.
* No heuristic, then run many randomized potential solutions and use LOS to find the best.
* LOS is not a trivial task. Lots of craftsmanship.
* Suffer exponential performance, but there may be algorithms, while still exponential, such as $$O(2^n)$$, which are still better than brute-force $$O(n!)$$ performance (i.e., $$O(n^n)$$).

# Tool Box
Abraham Maslow wrote, "If your tool box only contains a hammer, every problem tends to look like a nail." Learn new algorithms to add to your tool box. Books are a good source as well as the internet. MOOCs have been fantastic. Algorithm Coursera courses are available from Stanford, Princeton, Rice University, UC San Diego, et al. One does not need to master all algorithms. One needs to know of their existence and where to learn more about them.

# Reference Algorithm Repositories
If you have a problem for which you don't have an algorithm at hand, but you feel like an algorithm surely exists, consult a <a href="http://en.wikipedia.org/wiki/List_of_algorithms">list of algorithms</a> or a <a href="http://en.wikipedia.org/wiki/List_of_algorithm_general_topics">list of algorithm topics</a> or just Google "algorithm list". What you're seeking may very well be on one of these lists.
